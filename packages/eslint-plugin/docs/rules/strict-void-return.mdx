---
description: 'Disallow passing a value-returning function in a position accepting a void function.'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

> üõë This file is source code, not the primary documentation location! üõë
>
> See **https://typescript-eslint.io/rules/strict-void-return** for documentation.

## Rule Details

TypeScript considers functions returning a value to be assignable to a function returning void.
Using this feature of TypeScript can lead to bugs or confusing code.

## Examples

### Unsafety

Passing a value-returning function in a place expecting a void function can be unsound.

<Tabs>
<TabItem value="‚ùå Incorrect">

```ts
const bad: () => void = () => 2137;
const func = Math.random() > 0.1 ? bad : prompt;
const val = func();
if (val) console.log(val.toUpperCase()); // ‚ùå Crash if bad was called
```

</TabItem>
<TabItem value="‚úÖ Correct">

```ts
const good: () => void = () => {};
const func = Math.random() > 0.1 ? good : prompt;
const val = func();
if (val) console.log(val.toUpperCase()); // ‚úÖ No crash
```

</TabItem>
</Tabs>

### Unhandled promises

If a promise is returned from a callback that should return void,
it won't be awaited and its rejection will be silently ignored or crash the process depending on runtime.

<Tabs>
<TabItem value="‚ùå Incorrect">

```ts
declare function takesCallback(cb: () => void): void;

takesCallback(async () => {
  const response = await fetch('https://api.example.com/');
  const data = await response.json();
  console.log(data);
});
```

</TabItem>
<TabItem value="‚úÖ Correct">

```ts
declare function takesCallback(cb: () => void): void;

takesCallback(() => {
  (async () => {
    const response = await fetch('https://api.example.com/');
    const data = await response.json();
    console.log(data);
  })().catch(console.error);
});
```

</TabItem>
</Tabs>

:::info
If you only care about promises, you can use the [`no-misused-promises`](no-misused-promises.mdx) rule instead.
:::

:::tip
Use [`no-floating-promises`](no-floating-promises.mdx) to also enforce error handling of non-awaited promises.
:::

### Ignored generators

If a generator is returned from a void function it won't even be started.

<Tabs>
<TabItem value="‚ùå Incorrect">

```ts
declare function takesCallback(cb: () => void): void;

takesCallback(function* () {
  console.log('Hello');
  yield;
  console.log('World');
});
```

</TabItem>
<TabItem value="‚úÖ Correct">

```ts
declare function takesCallback(cb: () => void): void;

takesCallback(() => {
  function* gen() {
    console.log('Hello');
    yield;
    console.log('World');
  }
  for (const _ of gen());
});
```

</TabItem>
</Tabs>

### Probable mistakes

Returning a value from a void function is likely a mistake on part of the programmer.
This rule will often warn you early when using a function in a wrong way.

<Tabs>
<TabItem value="‚ùå Incorrect">

```ts
['Kazik', 'Zenek'].forEach(name => `Hello, ${name}!`);
```

</TabItem>
<TabItem value="‚úÖ Correct">

```ts
['Kazik', 'Zenek'].forEach(name => console.log(`Hello, ${name}!`));
```

</TabItem>
</Tabs>

## Options

### `considerOtherOverloads`

Whether to assume that an any-returning callback argument should be treated as a void callback,
if there exists another overload where it is typed as returning void.

This is required to correctly detect `addEventListener`'s callback as void callback,
because otherwise the call always resolves to the any-returning signature.

Additional incorrect code when the option is **enabled**:

<Tabs>
<TabItem value="‚ùå Incorrect">

```ts option='{ "considerOtherOverloads": true }'
/// <reference lib="dom" />

document.addEventListener('click', () => {
  return 'Clicked';
});
```

</TabItem>
<TabItem value="‚úÖ Correct">

```ts option='{ "considerOtherOverloads": true }'
/// <reference lib="dom" />

document.addEventListener('click', () => {
  console.log('Clicked');
});
```

</TabItem>
</Tabs>

### `considerBaseClass`

Whether to enforce class methods which override a void method to also be void.

Additional incorrect code when the option is **enabled**:

<Tabs>
<TabItem value="‚ùå Incorrect">

```ts option='{ "considerBaseClass": true }'
/// <reference lib="dom" />

class MyElement extends HTMLElement {
  click() {
    super.click();
    return 'Clicked';
  }
}
```

</TabItem>
<TabItem value="‚úÖ Correct">

```ts option='{ "considerBaseClass": true }'
/// <reference lib="dom" />

class MyElement extends HTMLElement {
  click() {
    super.click();
    console.log('Clicked');
  }
}
```

</TabItem>
</Tabs>

### `considerImplementedInterfaces`

Whether to enforce class methods which implement a void method to also be void.

Additional incorrect code when the option is **enabled**:

<Tabs>
<TabItem value="‚ùå Incorrect">

```ts option='{ "considerImplementedInterfaces": true }'
/// <reference lib="dom" />

class FooListener implements EventListenerObject {
  handleEvent() {
    return 'Handled';
  }
}
```

</TabItem>
<TabItem value="‚úÖ Correct">

```ts option='{ "considerImplementedInterfaces": true }'
/// <reference lib="dom" />

class FooListener implements EventListenerObject {
  handleEvent() {
    console.log('Handled');
  }
}
```

</TabItem>
</Tabs>

### `allowReturnPromiseIfTryCatch`

Whether to allow returned promises
if they are returned from an async function expression
whose whole body is wrapped in a try-catch block.

This offers an alternative to an async IIFE for handling errors in async callbacks.

Additional incorrect code when the option is **disabled**:

<Tabs>
<TabItem value="‚ùå Incorrect">

```ts option='{ "allowReturnPromiseIfTryCatch": false }'
const cb: () => void = async () => {
  try {
    const response = await fetch('https://api.example.com/');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
};
```

</TabItem>
<TabItem value="‚úÖ Correct">

```ts option='{ "allowReturnPromiseIfTryCatch": false }'
const cb: () => void = () => {
  (async () => {
    const response = await fetch('https://api.example.com/');
    const data = await response.json();
    console.log(data);
  })().catch(console.error);
};
```

</TabItem>
</Tabs>

### `allowReturnUndefined`

Whether to allow a function returning `undefined` to be used in place expecting a `void` function.
When disabled, `void` operator can't be used to discard the return value, because it evaluates to undefined.
Disable this to enforce a consistent style across the codebase.

:::note
Note that even when disabled it will still allow `return functionReturningVoid()`.
If you want to disallow that too, use the [`no-confusing-void-expression`](./no-confusing-void-expression.mdx) rule.
:::

Additional incorrect code when the option is **disabled**:

<Tabs>
<TabItem value="‚ùå Incorrect">

```ts option='{ "allowReturnUndefined": false }'
let cb: () => void;

cb = () => undefined;

cb = () => {
  return void 0;
};
```

</TabItem>
<TabItem value="‚úÖ Correct">

```ts option='{ "allowReturnUndefined": false }'
let cb: () => void;

cb = () => {};

cb = () => {
  return;
};
```

</TabItem>
</Tabs>

### `allowReturnNull`

Whether to allow a function returning `null` to be used in place expecting a `void` function.

Additional incorrect code when the option is **disabled**:

<Tabs>
<TabItem value="‚ùå Incorrect">

```ts option='{ "allowReturnNull": false }'
let cb: () => void;

cb = () => null;

cb = () => {
  return null;
};
```

</TabItem>
<TabItem value="‚úÖ Correct">

```ts option='{ "allowReturnNull": false }'
let cb: () => void;

cb = () => {};

cb = () => {
  return;
};
```

</TabItem>
</Tabs>

### `allowReturnAny`

Whether to allow a function returning `any` to be used in place expecting a `void` function.

Additional incorrect code when the option is **disabled**:

<Tabs>
<TabItem value="‚ùå Incorrect">

```ts option='{ "allowReturnAny": false }'
declare function fn(cb: () => void): void;

fn(() => JSON.parse('{}'));

fn(() => {
  return someUntypedApi();
});
```

</TabItem>
<TabItem value="‚úÖ Correct">

```ts option='{ "allowReturnAny": false }'
declare function fn(cb: () => void): void;

fn(() => void JSON.parse('{}'));

fn(() => {
  someUntypedApi();
});
```

</TabItem>
</Tabs>

## When Not To Use It

Primitive values returned from void functions are usually safe.
If you don't care about returning them you can use [`no-misused-promises`](./no-misused-promises.mdx) instead.

In browser context, an unhandled promise will be reported as an error in the console.
It's a always a good idea to also show some kind of indicator on the page that something went wrong,
but if you are just prototyping or don't care about that, the default behavior might be acceptable.
In such case, instead of handling the promises and `console.error`ing them anyways, you can just disable this rule.

Similarly, the default behavior of crashing the process on unhandled promise rejection
might be acceptable when developing, for example, a CLI tool.
If your promise handlers simply call `process.exit(1)` on rejection,
you might as well not use this rule and rely on the default behavior.

## Related To

- [`no-misused-promises`](./no-misused-promises.mdx) - A subset of this rule which only cares about promises.
- [`no-floating-promises`](./no-floating-promises.mdx) - Warns about unhandled promises in _statement_ positions.
- [`no-confusing-void-expression`](./no-confusing-void-expression.mdx) - Disallows returning _void_ values.

## Further Reading

- [TypeScript FAQ - Void function assignability](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-functions-returning-non-void-assignable-to-function-returning-void)
